<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo Using]]></title>
    <url>%2F2022%2F07%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy test More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router]]></title>
    <url>%2F2018%2F12%2F17%2Fvue-router%2F</url>
    <content type="text"><![CDATA[Vue-Router基本参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import routes from './routes'export default () =&gt; &#123; return new Router(&#123; routes， mode: 'history', // 去掉路由中的 #/ base: '/base/', // 所有通过配置的路由在进入的时候都会加上 /base 的前缀，但是 base 不是强制性的，在没有/base 的时候，路由还是能够正常的使用 linkActiveClass: 'activeLink', // 配置全局样式，修改链接被激活样式, 部分匹配 linkExactActiveClass: 'exactActiveLink', // 完全匹配的当前路由 scrollBehavior: (to, from, savedPosition) &#123; // 页面路径跳转的时候，页面滚动位置 if (avedPosition) &#123; return savedPosition &#125; else &#123; return &#123;x: 0, y: 0&#125; &#125; &#125;, parseQuery (query) &#123;&#125;, stringifyQuery (object) &#123;&#125;, fallback: true // 不是所有的浏览器都支持 history 的方式，Vue会自动变为hash的形式，一般设置成 true 就行了，如果为 false，单页应用就不存在了 &#125;)&#125;// 默认路由 / 自动重定向到 /app&#123; path: '/' redirect: '/app',&#125;// routes 基本路由&#123; path: '/app', name: 'app', components: &#123; default: Todo, a: Login &#125;, // 一般当做参数传递使用，防止vue自动忽略 meta: &#123; title: '', descriptiton: '' &#125;， children: [ &#123; path: 'children', component: Children &#125; ]&#125; // 动态query, query 不一定要在使用的时候拼上去，可以使用 props 的方式传递，当 props：true 的时候，只需要在组件中定义 props: ['id'] 即可，从而可以不用 $route 对象使用，不再需要 router 读取&#123; path: '/app/:id', props: true, name: 'app',&#125; // props 也可以是一个方法进行自定义&#123; path: '/app/:id', props: (route) =&gt; &#123; id: route.query.xx &#125; name: 'app',&#125; 在 main.js 中引入 123import createRouter from &apos;./router/routes&apos;const router = createRouter() webpack 配置 123456789101112131415// webpack.config.client.jsconst devServer = &#123; port: 8080, host: '0.0.0.0', overlay: &#123; errors: true &#125;, //如果 Router 对象中使用了mode: 'history'， 这里必须配置才能在手动进入项目的时候不会出现404，这里 index 的路径必须与 `webpack.config.base.js`中的 `output.publicPath` 相对应 `/public/` histortApiFallback: &#123; index: '/index.html', //index: '/public/index.html' &#125;, hot: true&#125; 常用API transition 组件包裹 router-view 路由切换时加上过渡动画 1234567891011121314//global.css.fade-enter-active, .fade-leave-active &#123; transition: opcity .5s&#125;.fade-enter, .fade-leave-to &#123; opcity: 0&#125;//.vue&lt;transition name=&quot;fade&quot;&gt; &lt;router-view /&gt;&lt;/transition&gt; this.$route 该对象包含路由的所有参数 params 动态参数 query hash参数 路由守卫 全局守卫 1234567891011121314151617router.beforeEach((to, from, next) =&gt; &#123; console.log('before each invoked') if (to.fullPath === '/app') &#123; next('/login') &#125; else &#123; next() &#125;&#125;)router.beforeResolve((to, from, next) =&gt; &#123; console.log('before resolve invoked') next()&#125;)router.afterEach((to, from) =&gt; &#123; console.log('after each invoked')&#125;) 路由配置守卫 12345678910111213141516&#123; path: '/', name: 'app', components: &#123; default: Todo, &#125;, meta: &#123; title: '', descriptiton: '' &#125;, //执行时间实在全局的 beforeEach 和 beforeResolve 之间 beforeEnter(to, from, next) &#123; console.log('app route before enter') next() &#125;&#125; 组件内守卫 123456789101112131415161718export default &#123; beforeRouteEnter (to, from, next) &#123; console.log(&apos;todo enter enter&apos;) next() &#125;, // 同样的路由形式在不通的参数改变的时候触发，优化了 watch 去监听路由参数的处理方式 beforeRouteUpdate (to, from, next) &#123; console.log(&apos;todo update enter&apos;) next() &#125;, beforeRouteLeave (to, from, next) &#123; console.log(&apos;todo leave enter&apos;) next() &#125;, data () &#123; return &#123;&#125; &#125;&#125; 在组件内路由中是没法获取组件实例 this 的，可以通过下面的方式获取组件实例 12345beforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; console.log(&apos;todo enter enter&apos;, vm) &#125;)&#125;, 异步路由 用法 123456789101112131415161718// 组件内配置component: () =&gt; import(&apos;../login/login.vue&apos;),// 修改 router&#123; path: &apos;/login&apos;, component: import(&apos;../login/login.vue&apos;)&#125;// 安装插件npm babel-plugin-syntax-dynamic-import -D// babelrc 文件&quot;plugins&quot;: [ &quot;syntax-dynamic-import&quot;]//重启服务 作用：加速首屏渲染的速度]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
      <tags>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex]]></title>
    <url>%2F2018%2F12%2F17%2Fvuex%2F</url>
    <content type="text"><![CDATA[Vuex安装、引入、使用 npm install vuex -S 引入并使用 12345678910111213141516import Vuex from 'vuex'const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; updateCount (state, num) &#123; state.count = num &#125; &#125;&#125;)export default () =&gt; &#123; return store&#125; 在 main.js 中引入 123456import Vuex from 'vuex'import createStore from './store/store'Vue.use(Vuex)const store = createStore() 调用 store 对象 12345678910mounted () &#123; console.log(this.$store) let i = 1 this.$store.commit('updateCount', i++)&#125;,computed: &#123; count () &#123; return this.$store.state.count &#125;&#125; 开发使用 store 文件目录结构 store store.js state state.js mutations mutations.js getters getters.js actions actions.js store.js 123456789101112131415161718import Vuex from 'vuex'import defaultState from './state/state'import mutations from './mutations/mutations'import getters from './getters/getters'import actions from './actions/actions'const isDev = process.env.NODE_ENV === 'development'export default () =&gt; &#123; return new Vuex.Store(&#123; strict： isDev, // 开发环境如果在外部修改 state 的值，会报出警告 state: defaultState, mutations, getters, actions &#125;)&#125; state.js data 12345export default &#123; count: 0, firstName: 'Jobs', fullName: 'Steve'&#125; mutations.js methods 同步操作 12345export default &#123; updateCount (state, num) &#123; state.count = num &#125;&#125; getters.js computed 12345export default &#123; fullName (state) &#123; return `$&#123;state.firstName&#125; $&#123;state.fullName&#125;` &#125;&#125; actions.js 异步操作 123456789export default &#123; updateCountAsync (store, data) &#123; setTimeout(() =&gt; &#123; store.commit(&apos;updateCount&apos;, &#123; num: data.num &#125;) &#125;, data.time) &#125;&#125; 组件内调用 123456789101112131415161718192021222324252627282930import &#123;mapState, mapGetters, mapMutations, mapActions&#125; from 'vuex'// Vuex辅助方法computed: &#123; //state ...mapState(['count']) // 同名 ...mapState(&#123; // 不同名 counter: 'count' &#125;) ...mapState(&#123; // 不同名, 可计算 counter （state）=&gt; state.count &#125;) // getters 调用方法同上 // mutations ...mapMutations(['updateCount']) this.updateCount(&#123; num1: 5, num2: 2 &#125;) // 简写为： ...mapActions(['updateCountAsync']) this.updateCountAsync(&#123; num: 5, time: 2000 &#125;) &#125; 如果不支持 ... 的语法，则需要安装babel-preset-stage-1 1npm i babel-preset-stage-1 -D babelrc 文件配置 1234"presets": [ "env", "stage-1"] Vue 官方推荐 state 中数据的修改推荐放在 mutations 中 mutations 和 actions的参数传递只能是两个，第一个是 state，第二个是一个对象，即 12345export default &#123; updateCount (state, &#123;num1, num2&#125;) &#123; state.count = num1 + num2 &#125;&#125; module 模块，可嵌套 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// Vuex 中定义modules: &#123; a: &#123; namespaced: true, //添加命名空间 state: &#123; text: 1 &#125;, mutations: &#123; updateText (state, text) &#123; state.text = text &#125; &#125;， getters: &#123; textPlus (state, getters, rootState) &#123; // rootState 为全局的 state return state.text + rootState.b.text &#125; &#125;, actions: &#123; add (&#123;state, commit, rootState &#125;) &#123; commit('updateText', &#123;num: 1&#125;, &#123;root: true&#125;) &#125; &#125; &#125;, b: &#123; state: &#123; text: 2 &#125; &#125;&#125;//组件中调用methods: &#123; ...mapMutations(['a/updateText']) ...mapActions(['a/add']) &#125;,computed: &#123; ...mapState(&#123; textA: state =&gt; state.a.text &#125;) ...mapGetters(&#123; textPlus: 'a/textPlus' &#125;) &#125;,mounted () &#123; this['a/updateText']('123') //调用 mutatitns this['a/add']() // 调用 actions&#125; 动态注册和解绑模块 123456789101112131415// 注册store.regigterModule('c', &#123; state: &#123; text: 3 &#125;&#125;)// 解绑store.unregigterModule('c')computed: &#123; ...mapState(&#123; textC：state =&gt; state.c.text &#125;)&#125; 热更新123456789101112131415161718192021222324252627282930export default () =&gt; &#123; const store = new Vuex.Store(&#123; state: defaultState, mutations, getters, actions &#125;) if (module.hot) &#123; module.hot.accept([ './state/state', './mutations/mutations', './getters/getters', './actions/actions' ], () =&gt; &#123; const newState = require('./state/state').default const newMutations = require('./mutations/mutations').default const newGetters = require('./getters/getters').default const newActions = require('./actions/actions').default store.hotUpdate(&#123; state: newState, mutations: newMutations, getters: newGetters, actions: newActions &#125;) &#125;) &#125; return store&#125; 常用API store.watch 12345store.watch((state) =&gt; &#123; state.count + 1 //监听想要得到的返回值&#125;, () =&gt; &#123; console.log('new count watched', newCount) // 作为第一个方法的回调&#125;) store.subscribe 123456789store.subscribe((mutation, state) =&gt; &#123; console.log(mutation.type) console.log(mutation.payload)&#125;)store.subscribe((action, state) =&gt; &#123; console.log(action.type) console.log(action.payload)&#125;) 定义 Vuex 插件 12345678910111213export default () =&gt; &#123; const store = new Vuex.Store(&#123; state: defaultState, mutations, getters, actions， plugins: [&#123; (store) =&gt; &#123; console.log('my plugin invoked') &#125; &#125;] &#125;)&#125;]]></content>
      <categories>
        <category>Vuex</category>
      </categories>
      <tags>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue基础]]></title>
    <url>%2F2018%2F12%2F17%2Fvue%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Vue 基础学习实例的属性和方法 app.$mount(&#39;#app&#39;) === #el: &#39;#app&#39; app.text(text为data中变量)直接访问 app.$data访问 data 属性 app.$props 访问 props 属性 app.$el === &#39;#app&#39; 根节点 app.$options 访问app实例的所有属性 app实例中 data 属性在改变的时候 render 方法会执行 123app.$options.render = （h）=&gt; &#123; return h('div', &#123;&#125;, 'new render function')&#125; app.$root === app app,$children 子组件属性 app.$slots 插槽 app.$scopedSlots 插槽 app.$refs 模板的引用，快速定位组件或者元素，如果作用在组件上，返回的是当前组件的实例，如果作用在元素上，返回的就是当前的元素， app.$isServer 判断是否为服务端渲染 app.$watch == watch属性 app.$on(&#39;text&#39;, (a, b) =&gt; {console.log(&#39;test emit&#39; + a + b)}) app.$emit(&#39;text&#39;, 1, 2) 事件绑定和监听的必须是同一个app，不会冒泡 app.$forceUpdate() 强制组件更新，如果在 data 中没有直接申明某个属性， 改变这个属性，并不能更新视图，最好的方法不是使用强制刷新，而是在 data 中定义这个属性并设置默认值 app.$set(app.obj, &#39;a&#39;, 1) 给 data 添加新属性 app.$delete(app.obj.a) 删除 data 中的 obj 属性 vm.$nextTick([callback]) 组件Dom更新使用 生命周期 beforeCreate 实例创建 Created beforeMount 数据挂载 mounted beforeUpdate 数据更新 updated activated 动态组件 keep-alive deactivated beforeDestroy 实例销毁 destroyed 可以只用 app.$ + 生命周期函数名 调用 服务端渲染的情况下只有 beforeCreate, created 执行 render 方法 123render (h) &#123; console.log('render 方法会在 beforeMounte 和 mounted 之间执行')&#125; renderError() 收集错误，仅限当前组件， 不会冒泡 errorCaptured() 收集错误，可冒泡，收集本身和所有子组件的错误，除非子组件停止了事件冒泡 数据绑定 v-html 数据绑定时将html字符串解析成html结构 v-bind 单项数据绑定简写为 : v-on事件绑定，简写为 @ v-model 表单元素数据双向绑定 非表单元素双向绑定 动态绑定类名 :class=&quot;{ active: isActive }&quot; 动态绑定类名 :class=&quot;[isActive ? active : &#39;&#39;]&quot; 数组内写表达式 :class=&quot;[{ active: isActive }]&quot; 合并上面两种方式，推荐 计算属性绑定 样式绑定（ vue 绑定样式的时候，会根据浏览器的不同自动添加浏览器前缀） :style=&quot;styles&quot; 数据绑定方式, [styles: Object] :style=&quot;[style1, style2]&quot; 绑定多个样式 计算属性和侦听器 computed 只有当前有依赖的 data 属性值发生改变时，才会重新计算执行 computed 拥有 get 和 set 方法，但是不到万不得已不要使用 set 方法 watch 所监听的 对象必须是 data 中的某个属性 watch 中包含 handler immediate: true deep: false三个属性 handler 是当所监听的对象发生改变的时候执行的回调方法 immediate: true watch 监听对象的方法是不会马上执行的，只有有改变的时候才会执行 handler， 当immediate 配置项为 true 的时候，watch的 handler 方法才会立即执行一次 deep: false默认为 false ，表示 watch 只会监听被监听对象的引用，不会监听内部的属性，只有当该对象被重新赋值的时候才会被监听到，当 deep: true 的时候才能监听到内部的属性值的改变 可以将内部属性以 &#39;obj.a&#39; 的方式去监听，就可以监听到内部属性的改变，推荐 不要试图在 computed 和 watch 中试图修改被监听的对象，不然可能会出现死循环的情况，尤其在 computed中 指令 v-bind 属性的绑定 v-text 标签内显示的内容 当出现&lt;div v-text=&quot;text&quot;&gt;&lt;/div&gt;不会显示双花括号中的内容 v-html 将数据当做 html 字符串的方式进行解析 v-show 是否显示当前节点，原理：display: none v-if 是否存在当前节点，(动态增删节点，引起 dom 重绘) v-else v-else-if 配合 v-if 进行条件渲染 v-for 遍历数组或者对象 12&lt;div v-for=&quot;(item, index) in arr&quot; :key=&quot;item&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/div&gt;&lt;div v-for=&quot;(value, key, index) in obj&quot; :key=&quot;key&quot;&gt;&#123;&#123; value &#125;&#125;&lt;/div&gt; 指定 key 就会缓存 dom 节点，在数据重新渲染的时候提高性能，一般在遍历数组的时候使用 item 作为key，如果使用 index 作为 key 的话，没有任何意义 v-on 事件绑定 v-model 一般作用于表单元素实现双向绑定 修饰符 v-model.number 转数字格式 v-model.trim 去掉首位空格 v-model.lazy 默认文本框绑定的是 input 事件, 当时该修饰符的时候绑定的事件就是 change 事件 v-pre 不解析 data 数据，直接输出 v-cloak 在vue代码还没有加载完成之前，可以给元素加上这个指令不显示组件，使用 webpack 打包之后这个指令一般用不到 v-once 数据绑定到节点中不会被修改，节省性能开销，vue 不再根据虚拟 Dom 检查该节点 组件 定义组件名最好用大写的方式，大驼峰方式，使用组件的时候使用短横线的形式 123456789101112131415161718const component = &#123; template: '&lt;div&gt;&lt;/div&gt;', data () &#123; return &#123; text: 123 &#125; &#125;&#125;new Vue(&#123; el: '#app' components: &#123; comp: component &#125;, template: ` &lt;comp&gt;&lt;/comp&gt; `&#125;) 定义组件的时候 data 必须是一个方法， 且 return 的必须是一个新建的对象，不能是已有的全局对象 props 作用 定义组件被外部使用的时候所需要的配置参数 12345678910111213141516171819202122232425262728293031//类型检查props: &#123; active: Boolean， onChange: Function&#125;//直接传值,不够严谨props: ['active', 'onChange']//严谨方式props: &#123; active： &#123; type：Boolean, required: true, default: true, validator (value) &#123; return typeof value === Boolean &#125; &#125;, obj: &#123; type：Object, //required: true, default () &#123; return newObj &#125; &#125; onChange: Function&#125;// 如果所传的值是一个对象，default 需要是一个方法返回一个默认对象// 如果有了 default ，required 则不会生效// validator可以自定义校验规则 命名和使用规范： 定义小驼峰命名方式，使用短横杠的方式 props 中的参数变量最好不要做主动修改，props 是单项数据流 extend 生成 Vue 的一个子类 1234const CompVue = Vue.extend(comp)new CompVue(&#123; el: '#app'&#125;) 生成的子类，data 属性和生命周期等都会进行合并，父类先执行，子类后执行 作用：组件的扩展和重构 子类通过 this.$parent 访问父类， 最好不要进行修改 model 属性，避免变量冲突，自定义 props 中的变量名 实现 v-model 的双向绑定 12345678910111213141516171819202122232425262728293031323334const component = &#123; model: &#123; prop: 'myValue', event: 'change' &#125;, props: ['myValue'], template: ` &lt;div&gt; &lt;input type="text" @input="handleInput" :value="myValue"&gt; &lt;/div&gt; `, methods: &#123; handleInput (e) &#123; this.$emit('change', e.target.value) &#125; &#125;&#125;new Vue(&#123; el: '#app', components: &#123; comp: component &#125;, data () &#123; return &#123; value: '123' &#125; &#125;, template: ` &lt;div&gt; &lt;comp-one v-model="value"&gt;&lt;/comp-one&gt; &lt;/div&gt; `&#125;) provide 和 inject 属性：组件内使用越级的实例 1234567891011121314151617181920212223242526272829const component = &#123; inject：['value', 'data'], template: ` &lt;div&gt;child component: &#123;&#123; data.value &#125;&#125;&lt;/div&gt; `&#125;new Vue(&#123; el: '#app', components: &#123; comp: component &#125;, provide () &#123; const data = &#123;&#125; Object.defineProperty(data, 'value', &#123; get: () =&gt; this.value, enumerable: true // 可被读取 &#125;) return &#123; value: this.value, data &#125; &#125;, data () &#123; return &#123; value: '123' &#125; &#125;,&#125;) render 方法 组件的 template 属性是通过 render 方法编译成为虚拟 Dom 1234567891011121314151617181920212223242526272829// 这里 createElement 就是 Vue 虚拟 dom 的概念 即 VNode 类render (createElement) &#123; return createElement('comp1', &#123; // 根节点 ref: 'comp1'， props: &#123; props1: this.value &#125;, on: &#123; click: this.handleClick &#125;, nativeOn: &#123; // 直接创建在根节点上 click: this.handleClick &#125;, domProps: &#123; //原生 dom 操作 innerHtml: '&lt;span&gt;123123&lt;/span&gt;' &#125;, slots: &#123; &#125; attrs: &#123; id: 'test-id' &#125; &#125;, //子节点 [ createElement('comp2', &#123; ref: 'comp2' &#125;, this.value) ])&#125; 插槽 在使用组件的中间添加内容 123456789101112131415161718192021222324252627282930const component = &#123; template: ` &lt;div&gt; &lt;slot name="header"&gt;&lt;/slot&gt; &lt;slot my-value="123"&gt;&lt;/slot&gt; // 具名插槽 &lt;/div&gt; `&#125;new Vue(&#123; el: '#app', components: &#123; comp: component &#125;, data () &#123; return &#123; value: '123' &#125; &#125;, template: ` &lt;div&gt; &lt;comp-one&gt; // 使用引用该组件的属性 &lt;span slot="header"&gt;&#123;&#123; value &#125;&#125;&lt;/span&gt; // 作用域插槽，使用组件内部定义的属性 &lt;span slot-scope="props"&gt;&#123;&#123; props.myValue &#125;&#125;&lt;/span&gt; &lt;/comp-one&gt; &lt;/div&gt; `&#125;)]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法总结]]></title>
    <url>%2F2018%2F12%2F16%2FMarkDown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[MarkDown文章信息1234567--- title: 文章标题 date: 2018-01-01 00:00:00 文章生成时间 categories: 文章分类目录 tags: 文章标签 description: 页面描述--- 斜体、粗体、删除线12341.*斜体* _斜体_2.**粗体**3.***加粗斜体***4.~~删除线~~ 示例 我是斜体 我也是斜体 我是粗体 我是加粗斜体 我是删除线 标题1234561.#h1#2.##h2##3.###h3###4.####h4####5.#####h5#####6.######h6###### 示例：为了文档完整这里不做示例测试 超链接行内式语法说明 []里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。链接文字’这样的形式。链接地址与链接标题前有一个空格。 1[链接文字](链接地址) 示例 百度一下 参考式语法说明 参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 如果链接文字本身可以做为链接标记，你也可以写成[链接文字][][链接文字]：链接地址 123[链接文字][链接标记][]: 链接地址 示例 Jobs 自动链接语法说明 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接 1&lt;http://www.baidu.com&gt; 示例 http://www.baidu.com 锚点语法说明 网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。 123目录&#123;#index&#125;[目录](#index) 示例 1示例会产生文档报错，这里不错演示 列表无序列表使用 *，+，- 表示无序列表。 1231. - 无序列表2. + 无序列表3. * 无序列表 示例 我是无序列表 我是无序列表 我是无序列表 有序列表有序列表则使用数字接着一个英文句点。 11. 有序列表 示例 我是有序列表 自定义列表语法说明 定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab) 12Jobs 这是对jobs的解释 示例 Jobs : 这是对Jobs 的解释 列表缩进语法说明 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符 1* 这是一个进行缩进的列表项 示例 这是一个进行缩进的列表项 包含引用的列表语法说明 1234* 这是一个引用列表 &gt; 第一项 &gt; 第二项 示例 这是一个引用列表 第一项 第二项 包含代码区块的引用如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： 1* &lt;这里是代码块&gt; 示例 特殊情况 在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠： 引用语法说明 引用需要在被引用的文本前加上&gt;符号。 1&gt; 这是一个引用 示例 这是一个引用 引用的多层嵌套语法说明 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; 示例 这是第三层引用嵌套 这是第二层引用嵌套 这是第一层引用嵌套 插入图片图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。 语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。 行内式1![图片Alt](图片地址 &quot;图片Title&quot;) 不忘初心，方得始终 参考式在文档要插入图片的地方写![图片Alt][标记] 在文档的最后写上[标记]:图片地址 “Title” 不忘初心，方得始终 注脚在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。 注意：经测试注脚与注脚之间必须空一行，不然会失效。 123这是一段文字[^1][^1]: 这是一个注脚 示例 这是一段文字^1 LaTeX 公式行内公式1$E=mc^2$ 示例 $E=mc^2$ 整行公式1$$\sum_&#123;i=1&#125;^n a_i=0$$ 示例 $$\sum_{i=1}^n a_i=0$$ 表格 不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。 列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。 第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。 123| 学号 | 姓名 | 性别 || - | - || 201458503204 | Jobs | 男 | 示例 学号 姓名 性别 201458503204 Jobs 男 添加一行：shift + Enter 分割线在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。可以在星号或是减号中间插入空格。 12***----- 示例 代码插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。 语法说明： 插入行内代码，即插入一个单词或者一句代码的情况，使用code这样的形式插入。 插入多行代码，可以使用缩进或者“code “,具体看示例。 注意： 缩进式插入前方必须有空行 行内式1`console.log()` 示例 1console.log() 多行代码用六个`包裹多行代码 123function foo () &#123;conslole.log(&apos;hello markdown&apos;)&#125; HTML原始代码在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理 123&lt;div class=&quot;footer&quot;&gt; © 2004 Foo Corporation&lt;/div&gt;]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css清除浮动常用方法]]></title>
    <url>%2F2018%2F12%2F12%2Fcss%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[css清除浮动常用方法总结浮动对布局带来的影响 css块级元素在页面中默认是独占一行且自上而下排列的，也就是所谓的文档标准流，但当我们遇到将块级元素水平排列的情况时，标准流已经不能满足我们的需求，使用浮动布局可能会是最简单快捷的方式 浮动会将行内元素转化成为块级元素，当然这也是脱离文档流的表现 如果要实现左右浮动之后,父容器没有设置高度，子容器全部浮动，下面还有内容跟在后面，这样就会出现后面的内容跑到浮动元素的下面去，显然这不是我们想要的结果，这时我们就需要考虑怎么清除浮动对后面元素产生的影响 如何清除浮动 使用clear属性清理浮动 代码示例： clear: both | left | right 给父元素设置 overflow: hidden 推荐： 使用伪元素清除浮动 代码示例 123456789101112.clearfix:after &#123; content: ""; display: block; height: 0; line-height: 0; clear: both; visibility: hidden;//隐藏 &#125;.clearfix &#123; zoom:1;//兼容IE&#125; 使用时将 clerafix 这个类作用在浮动元素的父元素上即可 如果使用less或者sass，可以使用混入的方式，这样css样式就会和html代码完全分开，不需要再在html中加上额外的类名，当然实现代码还是上面的效果 less实现混入 1234567891011121314.a &#123; color: red;&#125;.mixin-class &#123; .a();&#125;result=&gt;.a &#123; color: red;&#125;.mixin-class &#123; color: red;&#125; 具体参见： less混入 sass实现混入 123456789101112131415定义：（@mixin）@mixin large-text &#123; font: &#123; family: Arial; size: 20px; weight: bold; &#125; color: #ff0000;&#125;引用：(@include).page-title &#123; @include large-text; padding: 4px; margin-top: 10px;&#125; 具体参见： sass混入]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
